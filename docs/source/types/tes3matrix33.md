# tes3matrix33
<div class="search_terms" style="display: none">tes3matrix33, matrix33</div>

<!---
	This file is autogenerated. Do not edit this file manually. Your changes will be ignored.
	More information: https://github.com/MWSE/MWSE/tree/master/docs
-->

A 3 by 3 matrix.

## Properties

### `x`
<div class="search_terms" style="display: none">x</div>

The first row of the matrix.

**Returns**:

* `result` ([tes3vector3](../types/tes3vector3.md))

***

### `y`
<div class="search_terms" style="display: none">y</div>

The second row of the matrix.

**Returns**:

* `result` ([tes3vector3](../types/tes3vector3.md))

***

### `z`
<div class="search_terms" style="display: none">z</div>

The third row of the matrix.

**Returns**:

* `result` ([tes3vector3](../types/tes3vector3.md))

***

## Methods

### `__tostring`
<div class="search_terms" style="display: none">__tostring</div>

Converts the matrix to a string with 2 decimal places.

```lua
local result = myObject:__tostring()
```

**Returns**:

* `result` (string)

***

### `copy`
<div class="search_terms" style="display: none">copy</div>

Creates a copy of the matrix.

```lua
local result = myObject:copy()
```

**Returns**:

* `result` ([tes3matrix33](../types/tes3matrix33.md))

***

### `fromEulerXYZ`
<div class="search_terms" style="display: none">fromeulerxyz</div>

Fills the matrix with values from euler angles in radians.

```lua
myObject:fromEulerXYZ(x, y, z)
```

**Parameters**:

* `x` (number)
* `y` (number)
* `z` (number)

***

### `fromQuaternion`
<div class="search_terms" style="display: none">fromquaternion</div>

Fill the matrix by converting a quaternion.

```lua
myObject:fromQuaternion(quaternion)
```

**Parameters**:

* `quaternion` ([niQuaternion](../types/niQuaternion.md))

***

### `getForwardVector`
<div class="search_terms" style="display: none">getforwardvector, forwardvector</div>

Returns a copy of the forward vector component. This is the second column of the matrix.

```lua
local result = myObject:getForwardVector()
```

**Returns**:

* `result` ([tes3vector3](../types/tes3vector3.md))

***

### `getRightVector`
<div class="search_terms" style="display: none">getrightvector, rightvector</div>

Returns a copy of the right vector component. This is the first column of the matrix.

```lua
local result = myObject:getRightVector()
```

**Returns**:

* `result` ([tes3vector3](../types/tes3vector3.md))

***

### `getUpVector`
<div class="search_terms" style="display: none">getupvector, upvector</div>

Returns a copy of the up vector component. This is the third column of the matrix.

```lua
local result = myObject:getUpVector()
```

**Returns**:

* `result` ([tes3vector3](../types/tes3vector3.md))

***

### `invert`
<div class="search_terms" style="display: none">invert</div>

Inverts the matrix.

```lua
local matrix, valid = myObject:invert()
```

**Returns**:

* `matrix` ([tes3matrix33](../types/tes3matrix33.md))
* `valid` (boolean)

***

### `lookAt`
<div class="search_terms" style="display: none">lookat</div>

Updates the matrix so that its forward and up vectors point toward the given directions.

```lua
myObject:lookAt(forward, up)
```

**Parameters**:

* `forward` ([tes3vector3](../types/tes3vector3.md))
* `up` ([tes3vector3](../types/tes3vector3.md))

??? example "Example: Using the `lookAt` method to rotate a scene graph line along the view direction"

	```lua
	
	---@type niSwitchNode, niCamera
	local line, camera
	local verticalOffset = tes3vector3.new(0, 0, -5)
	
	local function onLoaded()
		-- MWSE ships with a mesh which contains a few useful widgets.
		-- These can be used during debugging.
		local mesh = tes3.loadMesh("mwse\\widgets.nif") --[[@as niNode]]
		local widgets = {
			-- 3D coordinate axes
			arrows = mesh:getObjectByName("unitArrows") --[[@as niTriShape]],
			-- A common switch node that has three almost infinite lines
			-- along each coordinate exis
			axes = mesh:getObjectByName("axisLines") --[[@as niSwitchNode]],
			plane = mesh:getObjectByName("unitPlane") --[[@as niTriShape]],
			sphere = mesh:getObjectByName("unitSphere") --[[@as niTriShape]]
		}
	
		local root = tes3.worldController.vfxManager.worldVFXRoot
		---@cast root niNode
	
		line = widgets.axes:clone() --[[@as niSwitchNode]]
		root:attachChild(line)
		root:update()
	
		-- switchIndex = 0 - x axis (red)
		-- switchIndex = 1 - y axis (green)
		-- switchIndex = 2 - z axis (blue)
		line.switchIndex = 1
	
		camera = tes3.worldController.worldCamera.cameraData.camera
	end
	event.register(tes3.event.loaded, onLoaded)
	
	local function simulateCallback()
		-- Let's make the line's origin at the eye position.
		-- The position is offset -5 along the Z axis, so that
		-- that we can actually see the line (the line isn't
		-- visible if looking directly along the line).
		line.translation = tes3.getPlayerEyePosition() + verticalOffset
	
		local rotation = tes3matrix33.new()
	
		-- Make the line point in the look direction.
		-- We'll get the direction vector from the world camera.
		rotation:lookAt(camera.worldDirection, camera.worldUp)
		line.rotation = rotation
		line:update()
	end
	event.register(tes3.event.simulate, simulateCallback)

	```

***

### `reorthogonalize`
<div class="search_terms" style="display: none">reorthogonalize</div>

Reorthogonalizes the matrix.

```lua
local result = myObject:reorthogonalize()
```

**Returns**:

* `result` (boolean)

***

### `toEulerXYZ`
<div class="search_terms" style="display: none">toeulerxyz</div>

Converts the matrix to series of rotations along each axis in radians.

```lua
local vector3, isUnique = myObject:toEulerXYZ()
```

**Returns**:

* `vector3` ([tes3vector3](../types/tes3vector3.md))
* `isUnique` (boolean)

***

### `toEulerZYX`
<div class="search_terms" style="display: none">toeulerzyx</div>

Converts the matrix to series of rotations along each axis in radians.

```lua
local vector3, isUnique = myObject:toEulerZYX()
```

**Returns**:

* `vector3` ([tes3vector3](../types/tes3vector3.md))
* `isUnique` (boolean)

***

### `toIdentity`
<div class="search_terms" style="display: none">toidentity</div>

Converts the matrix to the identity matrix's values.

```lua
myObject:toIdentity()
```

***

### `toQuaternion`
<div class="search_terms" style="display: none">toquaternion</div>

Convert the matrix into a quaternion.

```lua
local result = myObject:toQuaternion()
```

**Returns**:

* `result` ([niQuaternion](../types/niQuaternion.md))

***

### `toRotation`
<div class="search_terms" style="display: none">torotation</div>

Makes this matrix a rotation matrix with provided axis-angle rotation parameters.

```lua
myObject:toRotation(angle, x, y, z)
```

**Parameters**:

* `angle` (number)
* `x` (number)
* `y` (number)
* `z` (number)

***

### `toRotationX`
<div class="search_terms" style="display: none">torotationx</div>

Fills this matrix with the values needed to rotate a 3-by-1 vector or 3-by-N matrix of vectors around the X axis by `x` radians. For the rotation matrix A and vector v, the rotated vector is given by A * v.

```lua
myObject:toRotationX(x)
```

**Parameters**:

* `x` (number): In radians.

***

### `toRotationY`
<div class="search_terms" style="display: none">torotationy</div>

Fills this matrix with the values needed to rotate a 3-by-1 vector or 3-by-N matrix of vectors around the Y axis by `y` radians. For the rotation matrix A and vector v, the rotated vector is given by A * v.

```lua
myObject:toRotationY(y)
```

**Parameters**:

* `y` (number): In radians.

***

### `toRotationZ`
<div class="search_terms" style="display: none">torotationz</div>

Fills this matrix with the values needed to rotate a 3-by-1 vector or 3-by-N matrix of vectors around the Z axis by `z` radians. For the rotation matrix A and vector v, the rotated vector is given by A * v.

```lua
myObject:toRotationZ(z)
```

**Parameters**:

* `z` (number): In radians.

***

### `toZero`
<div class="search_terms" style="display: none">tozero</div>

Zeroes out all values in the matrix.

```lua
myObject:toZero()
```

***

### `transpose`
<div class="search_terms" style="display: none">transpose</div>

No description yet available.

```lua
local result = myObject:transpose()
```

**Returns**:

* `result` ([tes3matrix33](../types/tes3matrix33.md))

***

## Functions

### `identity`
<div class="search_terms" style="display: none">identity</div>

Creates a new identity matrix.

```lua
local matrix = tes3matrix33.identity()
```

**Returns**:

* `matrix` ([tes3matrix33](../types/tes3matrix33.md))

***

### `new`
<div class="search_terms" style="display: none">new</div>

Creates a new 3 by 3 matrix from 3 provided vectors or 9 numbers. Creates an empty matrix if nothing is provided.

```lua
local matrix = tes3matrix33.new(x0, y0, z0, x1, y1, z1, x2, y2, z2)
```

**Parameters**:

* `x0` (number, [tes3vector3](../types/tes3vector3.md)): *Default*: `0`.
* `y0` (number, [tes3vector3](../types/tes3vector3.md)): *Default*: `0`.
* `z0` (number, [tes3vector3](../types/tes3vector3.md)): *Default*: `0`.
* `x1` (number): *Default*: `0`.
* `y1` (number): *Default*: `0`.
* `z1` (number): *Default*: `0`.
* `x2` (number): *Default*: `0`.
* `y2` (number): *Default*: `0`.
* `z2` (number): *Default*: `0`.

**Returns**:

* `matrix` ([tes3matrix33](../types/tes3matrix33.md))

***

## Math Operations

### Addition (`+`)

| Left operand type | Right operand type | Result type | Description |
| ----------------- | ------------------ | ----------- | ----------- |
| [tes3matrix33](../types/tes3matrix33.md) | [tes3matrix33](../types/tes3matrix33.md) | [tes3matrix33](../types/tes3matrix33.md) | The matrix addition. |

***

### Equality (`==`)

| Left operand type | Right operand type | Result type | Description |
| ----------------- | ------------------ | ----------- | ----------- |
| [tes3matrix33](../types/tes3matrix33.md) | [tes3matrix33](../types/tes3matrix33.md) | boolean | True if both matrices point to the same data. |

***

### Multiplication (`*`)

| Left operand type | Right operand type | Result type | Description |
| ----------------- | ------------------ | ----------- | ----------- |
| [tes3matrix33](../types/tes3matrix33.md) | [tes3matrix33](../types/tes3matrix33.md) | [tes3matrix33](../types/tes3matrix33.md) | The matrix multiplication. Geometrically, this will concatenate the transformations of both matrices in the resulting matrix. |
| [tes3matrix33](../types/tes3matrix33.md) | [tes3vector3](../types/tes3vector3.md) | [tes3vector3](../types/tes3vector3.md) | Multiplies the matrix by a vector. The resulting vector is starting vector with the matrix' transformations applied. |
| [tes3matrix33](../types/tes3matrix33.md) | number | [tes3matrix33](../types/tes3matrix33.md) | Multiplies the matrix by a scalar. |

***

### Subtraction (`-`)

| Left operand type | Right operand type | Result type | Description |
| ----------------- | ------------------ | ----------- | ----------- |
| [tes3matrix33](../types/tes3matrix33.md) | [tes3matrix33](../types/tes3matrix33.md) | [tes3matrix33](../types/tes3matrix33.md) | The matrix subtraction. |

