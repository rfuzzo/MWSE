# niNode
<div class="search_terms" style="display: none">ninode, node</div>

<!---
	This file is autogenerated. Do not edit this file manually. Your changes will be ignored.
	More information: https://github.com/MWSE/MWSE/tree/master/docs
-->

Base class that represents the nodes of a scene graph. A node can have any number of child nodes.

This type inherits the following: [niAVObject](../types/niAVObject.md), [niObjectNET](../types/niObjectNET.md), [niObject](../types/niObject.md).
??? example "Example: Attaching a mesh directly to the actor's scene graph"

	```lua
	
	--- This function will attach an equipment mesh directly to the
	--- reference's scene graph. The skeleton (bone names) in the
	--- equipment mesh should match the destination skeleton.
	---@param mesh niNode
	---@param reference tes3reference
	local function attachMesh(mesh, reference)
		for shape in table.traverse(mesh.children) do
			if shape:isInstanceOfType(ni.type.NiTriShape) then
				---@cast shape niTriShape
				local skin = shape.skinInstance
				local referenceRoot = reference.sceneNode
				---@cast referenceRoot niNode
	
				if skin then
					skin.root = referenceRoot:getObjectByName(skin.root.name) --[[@as niNode]]
					for i, bone in ipairs(skin.bones) do
						skin.bones[i] = referenceRoot:getObjectByName(bone.name)
					end
				end
				---@diagnostic disable-next-line
				referenceRoot:getObjectByName("Bip01"):attachChild(shape)
			end
		end
	end
	
	local function onLoaded()
		local mesh = tes3.loadMesh("c\\c_m_helseth_robe.nif"):clone() --[[@as niNode]]
		attachMesh(mesh, tes3.player)
	end
	event.register(tes3.event.loaded, onLoaded)

	```

??? example "Example: Adding new shapes to the scene graph"

	The most basic of the scene graph operations is attaching. Attaching a node to the elements of the scene graph will make it visible.

	```lua
	
	---@type niTriShape
	local arrows
	
	local function onLoaded()
		-- MWSE ships with a mesh which contains a few useful widgets.
		-- These can be used during debugging.
		local mesh = tes3.loadMesh("mwse\\widgets.nif") --[[@as niNode]]
		local widgets = {
			-- 3D coordinate axes
			arrows = mesh:getObjectByName("unitArrows") --[[@as niTriShape]],
			-- A common switch node that has three almost infinite lines
			-- along each coordinate exis
			axes = mesh:getObjectByName("axisLines") --[[@as niSwitchNode]],
			plane = mesh:getObjectByName("unitPlane") --[[@as niTriShape]],
			sphere = mesh:getObjectByName("unitSphere") --[[@as niTriShape]]
		}
	
		local root = tes3.worldController.vfxManager.worldVFXRoot
		---@cast root niNode
	
		-- Objects in the scene graph share as much same properties as possible, which
		-- allows for some optimizations. Because of that, we need to clone our object
		-- before attaching it to the scene graph.
		arrows = widgets.arrows:clone() --[[@as niTriShape]]
	
		-- The base size of the arrows is 1 unit. Let's make them a bit bigger.
		arrows.scale = 30
	
		-- Attaching our arrows shape to a node in the scene graph will
		-- make it actually visible in-game.
		root:attachChild(arrows)
	
		-- No changes are applied until the update() method was called on the parent node.
		root:update()
	end
	event.register(tes3.event.loaded, onLoaded)
	
	local function simulateCallback()
		-- Let's set the base position of the arrows in the in-game world to the player's
		-- eye position. Then we offset it in the direction of eye vector by 200 units.
		-- We get the arrows following the player's cursor at 200 units distance.
		arrows.translation = tes3.getPlayerEyePosition() + tes3.getPlayerEyeVector() * 200
		arrows:update()
	end
	event.register(tes3.event.simulate, simulateCallback)

	```

??? example "Example: Orienting an object so that it's perpendicular to the surface."

	In this example the unit arrows are placed perpendicular to the surface in the direction the player is looking at.

	```lua
	
	---@type niTriShape
	local arrows
	
	local function onLoaded()
		-- MWSE ships with a mesh which contains a few useful widgets.
		-- These can be used during debugging.
		local mesh = tes3.loadMesh("mwse\\widgets.nif") --[[@as niNode]]
		local widgets = {
			-- 3D coordinate axes
			arrows = mesh:getObjectByName("unitArrows") --[[@as niTriShape]],
			-- A common switch node that has three almost infinite lines
			-- along each coordinate exis
			axes = mesh:getObjectByName("axisLines") --[[@as niSwitchNode]],
			plane = mesh:getObjectByName("unitPlane") --[[@as niTriShape]],
			sphere = mesh:getObjectByName("unitSphere") --[[@as niTriShape]]
		}
	
		local root = tes3.worldController.vfxManager.worldVFXRoot
		---@cast root niNode
	
		-- Objects in the scene graph share as much same properties as possible, which
		-- allows for some optimizations. Because of that, we need to clone our object
		-- before attaching it to the scene graph.
		arrows = widgets.arrows:clone() --[[@as niTriShape]]
	
		-- The base size of the arrows is 1 unit. Let's make them a bit bigger.
		arrows.scale = 100
	
		-- Attaching our arrows shape to a node in the scene graph will
		-- make it actually visible in-game.
		root:attachChild(arrows)
	
		-- No changes are applied until the update() method was called on the parent node.
		root:update()
	end
	event.register(tes3.event.loaded, onLoaded)
	
	
	-- This is the up axis unit vector.
	local UP = tes3vector3.new(0, 0, 1)
	
	--- This function returns the difference in direction
	--- of two vectors in Euler angles in radians.
	---@param vec1 tes3vector3
	---@param vec2 tes3vector3
	---@return tes3vector3, boolean?
	local function rotationDifference(vec1, vec2)
		vec1 = vec1:normalized()
		vec2 = vec2:normalized()
	
		local axis = vec1:cross(vec2)
		local norm = axis:length()
		if norm < 1e-5 then
			return tes3vector3.new(0, 0, 0)
		end
	
		local angle = math.asin(norm)
		if vec1:dot(vec2) < 0 then
			angle = math.pi - angle
		end
	
		axis:normalize()
		local m = tes3matrix33.new()
		m:toRotation(-angle, axis.x, axis.y, axis.z)
		return m:toEulerXYZ()
	end
	
	
	local function simulateCallback()
		local hit = tes3.rayTest({
			position = tes3.getPlayerEyePosition(),
			direction = tes3.getPlayerEyeVector(),
			returnNormal = true,
			returnSmoothNormal = true,
			ignore = { tes3.player }
		})
		if not hit then return end
	
		-- First, set the the arrows position
		arrows.translation = hit.intersection
	
		-- Now, let's get the rotation
		local rotation = rotationDifference(UP, hit.normal)
		local m = tes3matrix33.new()
	
		-- We need to convert our rotation to a rotation matrix
		-- since nodes of scene graph store their rotations in
		-- that form.
		m:fromEulerXYZ(rotation.x, rotation.y, rotation.z)
		arrows.rotation = m
	
		arrows:update()
	end
	event.register(tes3.event.simulate, simulateCallback)

	```

## Properties

### `alphaProperty`
<div class="search_terms" style="display: none">alphaproperty</div>

Convenient access to this object's alpha property. Setting this value to be nil will erase the property, while setting it to a valid alpha property will set (or replace) it.

**Returns**:

* `result` ([niAlphaProperty](../types/niAlphaProperty.md), nil)

***

### `appCulled`
<div class="search_terms" style="display: none">appculled</div>

A flag indicating if this object is culled. When culled, it will not render, and raycasts ignore it.

**Returns**:

* `result` (boolean)

***

### `children`
<div class="search_terms" style="display: none">children</div>

*Read-only*. The children of the node. Can have `nil` entries.

**Returns**:

* `result` ([niAVObject](../types/niAVObject.md)[])

***

### `controller`
<div class="search_terms" style="display: none">controller</div>

*Read-only*. The first controller available on the object.

**Returns**:

* `result` ([niTimeController](../types/niTimeController.md))

***

### `effectList`
<div class="search_terms" style="display: none">effectlist</div>

*Read-only*. The effect list of the node. Attached effects affect the node and all of its child subtree geometry.

**Returns**:

* `result` ([niDynamicEffectLinkedList](../types/niDynamicEffectLinkedList.md))

***

### `extraData`
<div class="search_terms" style="display: none">extradata</div>

*Read-only*. The first extra data available on the object.

**Returns**:

* `result` ([niExtraData](../types/niExtraData.md))

***

### `flags`
<div class="search_terms" style="display: none">flags</div>

Flags, dependent on the specific object type.

**Returns**:

* `result` (number)

***

### `fogProperty`
<div class="search_terms" style="display: none">fogproperty</div>

Convenient access to this object's fog property. Setting this value to be nil will erase the property, while setting it to a valid fog property will set (or replace) it.

**Returns**:

* `result` ([niFogProperty](../types/niFogProperty.md), nil)

***

### `materialProperty`
<div class="search_terms" style="display: none">materialproperty</div>

Convenient access to this object's material property. Setting this value to be nil will erase the property, while setting it to a valid material property will set (or replace) it.

**Returns**:

* `result` ([niMaterialProperty](../types/niMaterialProperty.md), nil)

***

### `name`
<div class="search_terms" style="display: none">name</div>

The human-facing name of the given object.

**Returns**:

* `result` (string)

***

### `parent`
<div class="search_terms" style="display: none">parent</div>

*Read-only*. The object's parent. It may not have one if it is not attached to the scene.

**Returns**:

* `result` ([niNode](../types/niNode.md))

***

### `properties`
<div class="search_terms" style="display: none">properties</div>

*Read-only*. The list of properties attached to this `niAVObject`.

**Returns**:

* `result` ([niPropertyLinkedList](../types/niPropertyLinkedList.md))

***

### `refCount`
<div class="search_terms" style="display: none">refcount</div>

*Read-only*. The number of references that exist for this object. When this value reaches zero, the object will be deleted.

**Returns**:

* `result` (number)

***

### `rotation`
<div class="search_terms" style="display: none">rotation</div>

The object's local rotation matrix.

**Returns**:

* `result` ([tes3matrix33](../types/tes3matrix33.md))

***

### `RTTI`
<div class="search_terms" style="display: none">rtti</div>

*Read-only*. The runtime type information for this object. This is an alias for the `.runTimeTypeInformation` property.

**Returns**:

* `result` ([niRTTI](../types/niRTTI.md))

***

### `runTimeTypeInformation`
<div class="search_terms" style="display: none">runtimetypeinformation</div>

*Read-only*. The runtime type information for this object.

**Returns**:

* `result` ([niRTTI](../types/niRTTI.md))

***

### `scale`
<div class="search_terms" style="display: none">scale</div>

The object's local uniform scaling factor.

**Returns**:

* `result` (number)

***

### `stencilProperty`
<div class="search_terms" style="display: none">stencilproperty</div>

Convenient access to this object's stencil property. Setting this value to be nil will erase the property, while setting it to a valid stencil property will set (or replace) it.

**Returns**:

* `result` ([niStencilProperty](../types/niStencilProperty.md), nil)

***

### `texturingProperty`
<div class="search_terms" style="display: none">texturingproperty</div>

Convenient access to this object's texturing property. Setting this value to be nil will erase the property, while setting it to a valid texturing property will set (or replace) it.

**Returns**:

* `result` ([niTexturingProperty](../types/niTexturingProperty.md), nil)

***

### `translation`
<div class="search_terms" style="display: none">translation</div>

The object's local translation vector.

**Returns**:

* `result` ([tes3vector3](../types/tes3vector3.md))

***

### `velocity`
<div class="search_terms" style="display: none">velocity</div>

The object's local velocity.

**Returns**:

* `result` ([tes3vector3](../types/tes3vector3.md))

***

### `vertexColorProperty`
<div class="search_terms" style="display: none">vertexcolorproperty</div>

Convenient access to this object's vertex coloring property. Setting this value to be nil will erase the property, while setting it to a valid vertex coloring property will set (or replace) it.

**Returns**:

* `result` ([niVertexColorProperty](../types/niVertexColorProperty.md), nil)

***

### `worldBoundOrigin`
<div class="search_terms" style="display: none">worldboundorigin</div>

The world coordinates of the object's bounds origin.

**Returns**:

* `result` ([tes3vector3](../types/tes3vector3.md))

***

### `worldBoundRadius`
<div class="search_terms" style="display: none">worldboundradius</div>

The radius of the object's bounds.

**Returns**:

* `result` (number)

***

### `worldTransform`
<div class="search_terms" style="display: none">worldtransform</div>

The object's transformations in the world space.

**Returns**:

* `result` ([tes3transform](../types/tes3transform.md))

***

### `zBufferProperty`
<div class="search_terms" style="display: none">zbufferproperty</div>

Convenient access to this object's z-buffer property. Setting this value to be nil will erase the property, while setting it to a valid z-buffer property will set (or replace) it.

**Returns**:

* `result` ([niZBufferProperty](../types/niZBufferProperty.md), nil)

***

## Methods

### `addExtraData`
<div class="search_terms" style="display: none">addextradata, extradata</div>

Appends an extra data to the object.

```lua
myObject:addExtraData(extraData)
```

**Parameters**:

* `extraData` ([niExtraData](../types/niExtraData.md))

***

### `attachChild`
<div class="search_terms" style="display: none">attachchild</div>

Attaches the child to the children list of the node. Doesn't check to see if the object is already in the child list.

```lua
myObject:attachChild(child, useFirstAvailable)
```

**Parameters**:

* `child` ([niAVObject](../types/niAVObject.md))
* `useFirstAvailable` (boolean): *Default*: `false`. Use the first available space in the list. If `false` appends the child at the end of the list.

***

### `attachEffect`
<div class="search_terms" style="display: none">attacheffect</div>

Attaches a dynamic effect to the node. It will not attach the same effect twice.

```lua
myObject:attachEffect(effect)
```

**Parameters**:

* `effect` ([niDynamicEffect](../types/niDynamicEffect.md))

***

### `attachProperty`
<div class="search_terms" style="display: none">attachproperty</div>

Attaches a property to this object, without checking to see if the property or another of its type is already on the list. Property lists must not have more than one property of a given class (i.e. no two niTexturingProperty objects) attached at once, or else undefined behavior will result.

```lua
myObject:attachProperty(property)
```

**Parameters**:

* `property` ([niProperty](../types/niProperty.md))

***

### `clearTransforms`
<div class="search_terms" style="display: none">cleartransforms</div>

Resets the object's local transform.

```lua
myObject:clearTransforms()
```

***

### `clone`
<div class="search_terms" style="display: none">clone</div>

Creates a copy of this object.

```lua
local result = myObject:clone()
```

**Returns**:

* `result` ([niObject](../types/niObject.md))

***

### `copyTransforms`
<div class="search_terms" style="display: none">copytransforms</div>

Update object's local transform by copying from another source.

```lua
myObject:copyTransforms(source)
```

**Parameters**:

* `source` ([niAVObject](../types/niAVObject.md), [tes3transform](../types/tes3transform.md))

***

### `createBoundingBox`
<div class="search_terms" style="display: none">createboundingbox, boundingbox</div>

Calculates and creates a bounding box for the object. The existing bounding box, if any, will not be used, a fresh one will always be calculated.

```lua
local boundingBox = myObject:createBoundingBox()
```

**Returns**:

* `boundingBox` ([tes3boundingBox](../types/tes3boundingBox.md)): The newly created bounding box.

***

### `detachAllChildren`
<div class="search_terms" style="display: none">detachallchildren</div>

Detaches all children from the children list of the node.

```lua
myObject:detachAllChildren()
```

***

### `detachAllEffects`
<div class="search_terms" style="display: none">detachalleffects</div>

Detaches all dynamic effect from the effect list of the node.

```lua
myObject:detachAllEffects()
```

***

### `detachAllProperties`
<div class="search_terms" style="display: none">detachallproperties</div>

Detaches all the properties on the object and returns them in the table.

```lua
local result = myObject:detachAllProperties()
```

**Returns**:

* `result` ([niProperty](../types/niProperty.md)[])

***

### `detachChild`
<div class="search_terms" style="display: none">detachchild</div>

Detaches the child from the children list of the node. Returns the detached child.

```lua
local detachedChild = myObject:detachChild(child)
```

**Parameters**:

* `child` ([niAVObject](../types/niAVObject.md))

**Returns**:

* `detachedChild` ([niAVObject](../types/niAVObject.md))

***

### `detachChildAt`
<div class="search_terms" style="display: none">detachchildat</div>

Detaches the child at the specified index from the children list of the node. Returns the detached child.

```lua
local detachedChild = myObject:detachChildAt(index)
```

**Parameters**:

* `index` (integer)

**Returns**:

* `detachedChild` ([niAVObject](../types/niAVObject.md))

***

### `detachEffect`
<div class="search_terms" style="display: none">detacheffect</div>

Detaches the given dynamic effect from the effect list of the node, if it was present. Has no effect if the effect wasn't attached to the node.

```lua
myObject:detachEffect(effect)
```

**Parameters**:

* `effect` ([niDynamicEffect](../types/niDynamicEffect.md))

***

### `detachProperty`
<div class="search_terms" style="display: none">detachproperty</div>

Detaches and returns a property from the object which matches the given property type.

```lua
local result = myObject:detachProperty(type)
```

**Parameters**:

* `type` ([ni.propertyType](../references/ni/property-types.md)): The types are available in [`ni.propertyType`](https://mwse.github.io/MWSE/references/ni/property-types/) table.

**Returns**:

* `result` ([niProperty](../types/niProperty.md))

***

### `getEffect`
<div class="search_terms" style="display: none">geteffect, effect</div>

Gets the effect of the given type.

```lua
local effect = myObject:getEffect(type)
```

**Parameters**:

* `type` ([ni.dynamicEffectType](../references/ni/dynamic-effect-types.md)): Use the values from [`ni.dynamicEffectType`](https://mwse.github.io/MWSE/references/ni/dynamic-effect-types/) table.

**Returns**:

* `effect` ([niDynamicEffect](../types/niDynamicEffect.md), nil)

***

### `getGameReference`
<div class="search_terms" style="display: none">getgamereference, gamereference</div>

Searches for an niExtraData on this object to see if it has one that holds a related reference.

```lua
local reference = myObject:getGameReference(searchParents)
```

**Parameters**:

* `searchParents` (boolean): *Default*: `false`. If true, all parent objects (if applicable) are also searched.

**Returns**:

* `reference` ([tes3reference](../types/tes3reference.md))

***

### `getObjectByName`
<div class="search_terms" style="display: none">getobjectbyname, objectbyname</div>

Searches this node and all child nodes recursively for a node with a name that matches the argument.

```lua
local result = myObject:getObjectByName(name)
```

**Parameters**:

* `name` (string)

**Returns**:

* `result` ([niAVObject](../types/niAVObject.md))

***

### `getProperty`
<div class="search_terms" style="display: none">getproperty, property</div>

Gets an attached property by property type.

```lua
local result = myObject:getProperty(type)
```

**Parameters**:

* `type` ([ni.propertyType](../references/ni/property-types.md)): The types are available in [`ni.propertyType`](https://mwse.github.io/MWSE/references/ni/property-types/) table.

**Returns**:

* `result` ([niProperty](../types/niProperty.md))

***

### `getStringDataStartingWith`
<div class="search_terms" style="display: none">getstringdatastartingwith, stringdatastartingwith</div>

Searches for an niExtraData on this object to see if it has niStringExtraData that has its string start with the provided `value` argument.

```lua
local extra = myObject:getStringDataStartingWith(value)
```

**Parameters**:

* `value` (string): The first niStringExtraData starting with this value will be returned.

**Returns**:

* `extra` ([niStringExtraData](../types/niStringExtraData.md))

***

### `getStringDataWith`
<div class="search_terms" style="display: none">getstringdatawith, stringdatawith</div>

Searches for an niExtraData on this object to see if it has niStringExtraData that has the provided `value` argument in its string field.

```lua
local extra = myObject:getStringDataWith(value)
```

**Parameters**:

* `value` (string): The first niStringExtraData with this word will be returned.

**Returns**:

* `extra` ([niStringExtraData](../types/niStringExtraData.md))

***

### `hasStringDataStartingWith`
<div class="search_terms" style="display: none">hasstringdatastartingwith, stringdatastartingwith</div>

Searches for an niExtraData on this object to see if it has niStringExtraData that has its string start with the provided `value` argument. Returns true if the value was found.

```lua
local result = myObject:hasStringDataStartingWith(value)
```

**Parameters**:

* `value` (string): The value to search for.

**Returns**:

* `result` (boolean)

***

### `hasStringDataWith`
<div class="search_terms" style="display: none">hasstringdatawith, stringdatawith</div>

Searches for an niExtraData on this object to see if it has niStringExtraData that contains the provided `value` argument in its string field. Returns true if the value was found.

```lua
local result = myObject:hasStringDataWith(value)
```

**Parameters**:

* `value` (string): The value to search for.

**Returns**:

* `result` (boolean)

***

### `isAppCulled`
<div class="search_terms" style="display: none">isappculled, appculled</div>

Recursively checks if either the object or any of its parents are appCulled.

```lua
local result = myObject:isAppCulled()
```

**Returns**:

* `result` (boolean)

***

### `isFrustumCulled`
<div class="search_terms" style="display: none">isfrustumculled, frustumculled</div>

Checks if the object is frustum culled for the given camera.

```lua
local result = myObject:isFrustumCulled(camera)
```

**Parameters**:

* `camera` ([niCamera](../types/niCamera.md))

**Returns**:

* `result` (boolean)

***

### `isInstanceOfType`
<div class="search_terms" style="display: none">isinstanceoftype, instanceoftype</div>

Determines if the object is of a given type, or of a type derived from the given type.

```lua
local result = myObject:isInstanceOfType(type)
```

**Parameters**:

* `type` ([ni.type](../references/ni/types.md)): Use values in the [`ni.type`](https://mwse.github.io/MWSE/references/ni/types/) table.

**Returns**:

* `result` (boolean)

***

### `isOfType`
<div class="search_terms" style="display: none">isoftype, oftype</div>

Determines if the object is of a given type.

```lua
local result = myObject:isOfType(type)
```

**Parameters**:

* `type` ([ni.type](../references/ni/types.md)): Use values in the [`ni.type`](https://mwse.github.io/MWSE/references/ni/types/) table.

**Returns**:

* `result` (boolean)

***

### `prependController`
<div class="search_terms" style="display: none">prependcontroller</div>

Add a controller to the object as the first controller.

```lua
myObject:prependController(controller)
```

**Parameters**:

* `controller` ([niTimeController](../types/niTimeController.md))

***

### `propagatePositionChange`
<div class="search_terms" style="display: none">propagatepositionchange</div>

Alias for `update()` method. Updates the world transforms of this node and its children, which makes changes visible for rendering. Use after changing any local rotation, translation, scale, bounds or after attaching and detaching nodes.

!!! tip
	It's best to "batch up" calls to this method. For example, when transform of an object its parent and grandparent are all changed during the same frame, it is much more efficient to call this method only on the grandparent object after all transforms have been changed. Also, consider calling this function as low as possible on a scene graph.


```lua
myObject:propagatePositionChange({ time = ..., controllers = ..., bounds = ... })
```

**Parameters**:

* `args` (table): *Optional*.
	* `time` (number): *Default*: `0`. This parameter is the time-slice for transformation and bounds updates
	* `controllers` (boolean): *Default*: `false`. Update object's controllers?
	* `bounds` (boolean): *Default*: `true`. Update object's bounds?

***

### `removeAllControllers`
<div class="search_terms" style="display: none">removeallcontrollers, allcontrollers</div>

Removes all controllers.

```lua
myObject:removeAllControllers()
```

***

### `removeAllExtraData`
<div class="search_terms" style="display: none">removeallextradata, allextradata</div>

Removes all extra data.

```lua
myObject:removeAllExtraData()
```

***

### `removeController`
<div class="search_terms" style="display: none">removecontroller, controller</div>

Removes a controller from the object.

```lua
myObject:removeController(controller)
```

**Parameters**:

* `controller` ([niTimeController](../types/niTimeController.md))

***

### `removeExtraData`
<div class="search_terms" style="display: none">removeextradata, extradata</div>

Removes a specific extra data from the object.

```lua
myObject:removeExtraData(extraData)
```

**Parameters**:

* `extraData` ([niExtraData](../types/niExtraData.md))

***

### `saveBinary`
<div class="search_terms" style="display: none">savebinary</div>

Serializes the object, and writes it to the given file.

```lua
local success = myObject:saveBinary(path)
```

**Parameters**:

* `path` (string): The path to write the file at, relative to the Morrowind installation folder.

**Returns**:

* `success` (boolean): If true the object was successfully serialized.

***

### `setFlag`
<div class="search_terms" style="display: none">setflag, flag</div>

Sets a given NiAVObject flag. The specifics use of the flag is dependent on the real underlying type.

```lua
myObject:setFlag(state, index)
```

**Parameters**:

* `state` (boolean)
* `index` (number)

***

### `update`
<div class="search_terms" style="display: none">update</div>

Updates the world transforms of this node and its children, which makes changes visible for rendering. Use after changing any local rotation, translation, scale, bounds or after attaching and detaching nodes.

!!! tip	"Update Efficiency"
	It's best to "batch up" calls to this method. For example, when transform of an object its parent and grandparent are all changed during the same frame, it is much more efficient to call this method only on the grandparent object after all transforms have been changed. Also, consider calling this function as low as possible on a scene graph.


```lua
myObject:update({ time = ..., controllers = ..., children = ... })
```

**Parameters**:

* `args` (table): *Optional*.
	* `time` (number): *Default*: `0`. This parameter is passed to controllers. Only needed if controllers are being updated.
	* `controllers` (boolean): *Default*: `false`. Update controllers before updating transforms.
	* `children` (boolean): *Default*: `true`. Recursively updates the children of this node.

***

### `updateEffects`
<div class="search_terms" style="display: none">updateeffects, effects</div>

Update all attached effects. This method must be called at or above any object when dynamic effects are attached or detached from it

```lua
myObject:updateEffects()
```

***

### `updateProperties`
<div class="search_terms" style="display: none">updateproperties, properties</div>

Update all attached properties.

```lua
myObject:updateProperties()
```

***

## Functions

### `new`
<div class="search_terms" style="display: none">new</div>

Creates a new, empty NiNode.

```lua
local node = niNode.new()
```

**Returns**:

* `node` ([niNode](../types/niNode.md))

